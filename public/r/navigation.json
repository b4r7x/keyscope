{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "navigation",
  "title": "Navigation",
  "description": "Standalone keyboard navigation for role-based lists and tabs",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "src/hooks/use-navigation.ts",
      "content": "\"use client\";\n\nimport {\n  useState,\n  useCallback,\n  type RefObject,\n  type KeyboardEvent,\n} from \"react\";\n\nexport type NavigationRole = \"radio\" | \"checkbox\" | \"option\" | \"menuitem\" | \"button\" | \"tab\";\n\nexport interface UseNavigationOptions {\n  containerRef: RefObject<HTMLElement | null>;\n  role: NavigationRole;\n  value?: string | null;\n  onValueChange?: (value: string) => void;\n  onSelect?: (value: string, event: globalThis.KeyboardEvent) => void;\n  onEnter?: (value: string, event: globalThis.KeyboardEvent) => void;\n  onHighlightChange?: (value: string) => void;\n  wrap?: boolean;\n  enabled?: boolean;\n  preventDefault?: boolean;\n  onBoundaryReached?: (direction: \"up\" | \"down\") => void;\n  initialValue?: string | null;\n  upKeys?: string[];\n  downKeys?: string[];\n  orientation?: \"vertical\" | \"horizontal\";\n  skipDisabled?: boolean;\n}\n\nexport interface UseNavigationReturn {\n  highlighted: string | null;\n  isHighlighted: (value: string) => boolean;\n  highlight: (value: string) => void;\n  onKeyDown: (event: KeyboardEvent) => void;\n}\n\n/** @internal Core return type — includes movement primitives for composition. */\nexport interface UseNavigationCoreReturn {\n  highlighted: string | null;\n  isHighlighted: (value: string) => boolean;\n  highlight: (value: string) => void;\n  move: (delta: 1 | -1) => void;\n  focusIndex: (index: number) => void;\n  handleSelect: (event: globalThis.KeyboardEvent) => void;\n  handleEnter: (event: globalThis.KeyboardEvent) => void;\n  getElements: () => HTMLElement[];\n}\n\nfunction queryElements(\n  containerRef: RefObject<HTMLElement | null>,\n  role: NavigationRole,\n  skipDisabled: boolean,\n): HTMLElement[] {\n  if (!containerRef.current) return [];\n  const selector = skipDisabled\n    ? `[role=\"${role}\"]:not([aria-disabled=\"true\"])`\n    : `[role=\"${role}\"]`;\n  return Array.from(containerRef.current.querySelectorAll<HTMLElement>(selector));\n}\n\n/**\n * Core navigation state and movement logic.\n * Used internally by useNavigation and useScopedNavigation.\n * @internal\n */\nexport function useNavigationCore({\n  containerRef,\n  role,\n  value,\n  onValueChange,\n  onSelect,\n  onEnter,\n  onHighlightChange,\n  wrap = true,\n  onBoundaryReached,\n  initialValue = null,\n  skipDisabled = true,\n}: UseNavigationOptions): UseNavigationCoreReturn {\n  const [internalValue, setInternalValue] = useState<string | null>(initialValue);\n  const isControlled = value !== undefined;\n  const highlighted = isControlled ? value ?? null : internalValue;\n\n  const setFocusedValue = useCallback(\n    (nextValue: string) => {\n      if (isControlled) {\n        onValueChange?.(nextValue);\n      } else {\n        setInternalValue(nextValue);\n        onValueChange?.(nextValue);\n      }\n      onHighlightChange?.(nextValue);\n    },\n    [isControlled, onHighlightChange, onValueChange],\n  );\n\n  const getElements = useCallback(\n    () => queryElements(containerRef, role, skipDisabled),\n    [containerRef, role, skipDisabled],\n  );\n\n  const getFocusedIndex = useCallback((): number => {\n    const elements = getElements();\n    if (elements.length === 0) return -1;\n    if (!highlighted) return 0;\n    const index = elements.findIndex((el) => el.dataset.value === highlighted);\n    return index >= 0 ? index : 0;\n  }, [getElements, highlighted]);\n\n  const focusIndex = useCallback(\n    (index: number) => {\n      const elements = getElements();\n      const el = elements[index];\n      if (el?.dataset.value) {\n        el.scrollIntoView?.({ block: \"nearest\" });\n        setFocusedValue(el.dataset.value);\n      }\n    },\n    [getElements, setFocusedValue],\n  );\n\n  const move = useCallback(\n    (delta: 1 | -1) => {\n      const elements = getElements();\n      if (elements.length === 0) return;\n\n      const current = getFocusedIndex();\n      let next = current + delta;\n\n      if (next < 0) {\n        if (wrap) {\n          next = elements.length - 1;\n        } else {\n          onBoundaryReached?.(\"up\");\n          return;\n        }\n      } else if (next >= elements.length) {\n        if (wrap) {\n          next = 0;\n        } else {\n          onBoundaryReached?.(\"down\");\n          return;\n        }\n      }\n\n      focusIndex(next);\n    },\n    [getElements, getFocusedIndex, wrap, onBoundaryReached, focusIndex],\n  );\n\n  const handleSelect = useCallback(\n    (event: globalThis.KeyboardEvent) => {\n      if (highlighted) onSelect?.(highlighted, event);\n    },\n    [highlighted, onSelect],\n  );\n\n  const handleEnter = useCallback(\n    (event: globalThis.KeyboardEvent) => {\n      if (highlighted) {\n        if (onEnter) onEnter(highlighted, event);\n        else onSelect?.(highlighted, event);\n      }\n    },\n    [highlighted, onEnter, onSelect],\n  );\n\n  const isHighlighted = useCallback((v: string) => highlighted === v, [highlighted]);\n  const highlight = useCallback((v: string) => setFocusedValue(v), [setFocusedValue]);\n\n  return { highlighted, isHighlighted, highlight, move, focusIndex, handleSelect, handleEnter, getElements };\n}\n\n/**\n * Standalone keyboard navigation for role-based lists.\n * Returns an onKeyDown handler — no KeyboardProvider required.\n */\nexport function useNavigation(options: UseNavigationOptions): UseNavigationReturn {\n  const {\n    enabled = true,\n    preventDefault = true,\n    orientation = \"vertical\",\n    upKeys,\n    downKeys,\n  } = options;\n\n  const resolvedUpKeys = upKeys ?? (orientation === \"vertical\" ? [\"ArrowUp\"] : [\"ArrowLeft\"]);\n  const resolvedDownKeys = downKeys ?? (orientation === \"vertical\" ? [\"ArrowDown\"] : [\"ArrowRight\"]);\n\n  const { highlighted, isHighlighted, highlight, move, focusIndex, handleSelect, handleEnter, getElements } =\n    useNavigationCore(options);\n\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (!enabled) return;\n\n      const key = event.key;\n      const isMoveKey = resolvedUpKeys.includes(key) || resolvedDownKeys.includes(key);\n      const isSpecialKey = key === \"Home\" || key === \"End\" || key === \"Enter\" || key === \" \";\n      if (!isMoveKey && !isSpecialKey) return;\n\n      if (preventDefault) event.preventDefault();\n\n      const nativeEvent = event.nativeEvent as globalThis.KeyboardEvent;\n\n      if (resolvedUpKeys.includes(key)) { move(-1); return; }\n      if (resolvedDownKeys.includes(key)) { move(1); return; }\n\n      switch (key) {\n        case \"Home\": focusIndex(0); return;\n        case \"End\": {\n          const elements = getElements();\n          if (elements.length > 0) focusIndex(elements.length - 1);\n          return;\n        }\n        case \"Enter\": handleEnter(nativeEvent); return;\n        case \" \": handleSelect(nativeEvent); return;\n      }\n    },\n    [enabled, preventDefault, resolvedUpKeys, resolvedDownKeys, move, focusIndex, getElements, handleSelect, handleEnter],\n  );\n\n  return { highlighted, isHighlighted, highlight, onKeyDown };\n}",
      "type": "registry:hook"
    }
  ],
  "meta": {
    "client": true
  },
  "type": "registry:hook"
}